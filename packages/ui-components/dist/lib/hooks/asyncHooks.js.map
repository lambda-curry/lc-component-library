{
  "version": 3,
  "sources": ["../../../src/lib/hooks/asyncHooks.ts"],
  "sourcesContent": ["import { useEffect, useState } from 'react';\n\n// Returns a tuple with [responseData, catchError] from a promise.\n// The catchError will return as null if there is no caught error.\n// If there is a caught error, the responseData will be sent as an empty object.\n// Adapted from https://dev.to/sobiodarlington/better-error-handling-with-async-await-2e5m\nexport const handlePromise: <T = any>(promise: Promise<any>) => Promise<[T | null, any]> = <T>(promise: Promise<any>) =>\n  promise.then((data: T) => [data, null] as [T, any]).catch(err => [null, err]);\n\n// The useAsyncEffect function is a custom hook to pass asynchronous functions into.\n// Most helpful when you only want to load data once in functional components (since you don't have access to the\n// lifecycle hooks).\n// Adapted from https://github.com/facebook/react/issues/14326\nexport const useAsyncEffect = (\n  effect: () => Promise<any>,\n  onDestroy?: (arg: any) => void,\n  inputs: any[] = []\n): void => {\n  let stillAround = true;\n  let result: any;\n\n  useEffect(() => {\n    if (stillAround) {\n      effect()\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        .then(value => (result = value))\n        .catch(err => {\n          throw new Error(err);\n        });\n    }\n\n    return () => {\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      stillAround = false;\n      if (typeof onDestroy === 'function') {\n        onDestroy(result);\n      }\n    };\n  }, inputs);\n};\n\n// Src: https://usehooks.com/useDebounce/\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport const useDebounce = (value: any, delay: number): any => {\n  // State and setters for debounced value\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(\n    () => {\n      // Update debounced value after delay\n      const handler = setTimeout(() => {\n        setDebouncedValue(value);\n      }, delay);\n\n      // Cancel the timeout if value changes (also on delay change or unmount)\n      // This is how we prevent debounced value from updating if value is changed ...\n      // .. within the delay period. Timeout gets cleared and restarted.\n      return () => {\n        clearTimeout(handler);\n      };\n    },\n    [value, delay] // Only re-call effect if value or delay changes\n  );\n\n  return debouncedValue;\n};\n"],
  "mappings": "AAAA,gDAMO,KAAM,GAA8E,AAAI,GAC7F,EAAQ,KAAK,AAAC,GAAY,CAAC,EAAM,OAAmB,MAAM,GAAO,CAAC,KAAM,IAM7D,EAAiB,CAC5B,EACA,EACA,EAAgB,KACP,CACT,GAAI,GAAc,GACd,EAEJ,EAAU,IACJ,IACF,IAEG,KAAK,GAAU,EAAS,GACxB,MAAM,GAAO,CACZ,KAAM,IAAI,OAAM,KAIf,IAAM,CAEX,EAAc,GACV,MAAO,IAAc,YACvB,EAAU,KAGb,IAKQ,EAAc,CAAC,EAAY,IAAuB,CAE7D,KAAM,CAAC,EAAgB,GAAqB,EAAS,GAErD,SACE,IAAM,CAEJ,KAAM,GAAU,WAAW,IAAM,CAC/B,EAAkB,IACjB,GAKH,MAAO,IAAM,CACX,aAAa,KAGjB,CAAC,EAAO,IAGH",
  "names": []
}
