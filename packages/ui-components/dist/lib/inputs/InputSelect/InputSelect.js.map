{
  "version": 3,
  "sources": ["../../../../src/lib/inputs/InputSelect/InputSelect.tsx"],
  "sourcesContent": ["import React, { FC, useEffect, useState, ChangeEvent } from 'react';\nimport {\n  Autocomplete,\n  AutocompleteChangeDetails,\n  AutocompleteChangeReason,\n  AutocompleteGetTagProps,\n  AutocompleteProps,\n  FilterOptionsState\n} from '@material-ui/lab';\nimport { Paper, Chip } from '@material-ui/core';\nimport classNames from 'classnames';\nimport { InputText } from '../InputText/InputText';\nimport { Icon } from '../../icon/Icon';\nimport { InputProps } from '../InputBase';\nimport { isEqual as _isEqual, get as _get, set as _set } from 'lodash';\n\nimport './input-select.css';\nimport { lowercaseString } from '../../util/js-helpers';\n\nexport type AutoCompleteChange = (\n  event: ChangeEvent<any>,\n  value: any,\n  reason: AutocompleteChangeReason,\n  details?: AutocompleteChangeDetails<any> | undefined\n) => void;\n\nexport type InputSelectProps = Omit<InputProps, 'onChange'> & {\n  value?: any;\n  options: any[];\n  optionLabelKey?: string;\n  optionValueKey?: string;\n  autocompleteConfig?: Partial<AutocompleteProps<any, boolean, boolean, boolean>>;\n  allowCreateOption?: boolean;\n  disableFilterOptionsByValue?: boolean;\n  onChange?: AutoCompleteChange;\n};\n\nexport const InputSelect: FC<InputSelectProps> = ({\n  options,\n  optionLabelKey = 'label',\n  optionValueKey,\n  name,\n  className,\n  autocompleteConfig,\n  onChange,\n  allowCreateOption,\n  disableFilterOptionsByValue,\n  ...props\n}) => {\n  const allowCustomValue = autocompleteConfig?.freeSolo || allowCreateOption;\n  const isMultiselect = autocompleteConfig?.multiple;\n\n  const optionAndValueAreEqual = (option: any, value: any) => {\n    // Note: Sometimes we pass in the value as true value and sometimes value is the selected option.\n    return optionValueKey ? _get(option, optionValueKey) === value || _isEqual(option, value) : _isEqual(option, value);\n  };\n\n  const getOptionSelected = (option: any, value: any) => {\n    return optionAndValueAreEqual(option, value);\n  };\n\n  const getControlledValue = () => {\n    const valueFromProps = props.formikProps ? _get(props.formikProps.values, name) : props.value;\n    const selectedOption = options.find(option => getOptionSelected(option, valueFromProps));\n\n    const defaultValue = isMultiselect ? [] : null;\n\n    if (isMultiselect || (!selectedOption && allowCustomValue)) {\n      return valueFromProps || defaultValue;\n    }\n\n    return selectedOption || defaultValue;\n  };\n\n  const getNormalizedValueSingle = (newValue: any) => {\n    let isCustomValue = false;\n    let normalizedValue = newValue;\n\n    const selectedOption = options.find(option => getOptionSelected(option, newValue));\n\n    // Check to see if we have a matching option.\n    if (selectedOption) {\n      return optionValueKey ? _get(selectedOption, optionValueKey) : selectedOption;\n    }\n\n    if (typeof newValue === 'string') {\n      isCustomValue = true;\n      normalizedValue = _set({}, optionLabelKey, newValue);\n    } else if (newValue && newValue.inputValue) {\n      isCustomValue = true;\n      // Create a new value from the user input\n      normalizedValue = _set({}, optionLabelKey, newValue.inputValue);\n    }\n\n    if (isCustomValue) {\n      normalizedValue = _set(normalizedValue, optionValueKey || 'value', newValue.inputValue || newValue);\n    }\n\n    return optionValueKey && normalizedValue ? _get(normalizedValue, optionValueKey) : normalizedValue;\n  };\n\n  const getNormalizedValueMultiple = (newValues: any[]) =>\n    newValues.map(newValue => getNormalizedValueSingle(newValue));\n\n  const getNormalizedValue = (newValue: any) =>\n    isMultiselect ? getNormalizedValueMultiple(newValue) : getNormalizedValueSingle(newValue);\n\n  const filterOptions = (options: any[], params: FilterOptionsState<any>) =>\n    options.filter(option => {\n      const optionLabel = _get(option, optionLabelKey) || '';\n      const optionValue = option && optionValueKey ? _get(option, optionValueKey) : option;\n      const inputValue = lowercaseString(params.inputValue);\n\n      let valueMatch = false;\n      const labelMatch = lowercaseString(optionLabel).includes(inputValue);\n\n      if (!disableFilterOptionsByValue && (typeof optionValue === 'string' || typeof optionValue === 'number')) {\n        valueMatch = lowercaseString(optionValue).includes(inputValue);\n      }\n\n      return valueMatch || labelMatch;\n    });\n\n  const controlledValue = getControlledValue();\n\n  const [value, setValue] = useState(controlledValue);\n\n  // Note: We had to use a `useEffect` here to handle cases where the form is reset or manipulated outside of the input\n  // For some reason setting the initialInputValue in the initial useState did not reset the input on a form reset\n  useEffect(() => {\n    setValue(controlledValue);\n  }, [controlledValue]);\n\n  const autocompleteDefaultProps: AutocompleteProps<any, boolean, boolean, boolean> = {\n    options,\n    value,\n    onChange: (event, newValue, reason, details) => {\n      const normalizedValue = getNormalizedValue(newValue);\n\n      setValue(normalizedValue);\n\n      const hasSafeName = props.formikProps?.status?.formConfig?.safeName || props.inputConfig?.safeName;\n      if (props.formikProps?.setFieldValue)\n        props.formikProps.setFieldValue(hasSafeName ? `['${name}']` : name, normalizedValue);\n      if (typeof onChange === 'function') onChange(event, normalizedValue, reason, details);\n    },\n    openOnFocus: true,\n    closeIcon: <Icon className=\"lc-input-select-icon-close\" name=\"close\" />,\n    popupIcon: <Icon className=\"lc-input-select-icon-popup\" name=\"chevronDown\" />,\n    renderInput: params => {\n      const inputProps = {\n        ...params.inputProps,\n        ...props.inputProps,\n        disabled: props.disabled\n      };\n\n      return (\n        <InputText\n          name={name}\n          {...params}\n          {...props}\n          inputProps={inputProps}\n          // Prevent InputBase from calling `formikProps.handleChange`\n          // Because it is overriding our change event and preventing\n          // the creation of custom options\n          formikProps={{ ...props.formikProps, handleChange: undefined }}\n        />\n      );\n    },\n    PaperComponent: props => <Paper className=\"lc-input-select-paper\" {...props} />,\n    getOptionLabel: (option: { [key: string]: any }) => _get(option, optionLabelKey) || '',\n    getOptionDisabled: option => option.isDisabled,\n    getOptionSelected,\n    filterOptions,\n    disableClearable: true,\n    autoHighlight: false,\n    autoSelect: false,\n    autoComplete: true,\n    renderTags: (valueArray: any[], getTagProps: AutocompleteGetTagProps) => (\n      <>\n        {valueArray.map((valueArrayItem, index) => {\n          const selectedOption = options.find(option => getOptionSelected(option, valueArrayItem));\n          const label = selectedOption\n            ? _get(selectedOption, optionLabelKey)\n            : _get(valueArrayItem, optionLabelKey) || valueArrayItem;\n          return <Chip {...getTagProps({ index })} deleteIcon={<Icon name=\"close\" />} label={label} />;\n        })}\n      </>\n    )\n  };\n\n  const autocompleteFreeSoloProps = {\n    disableClearable: false,\n    autoHighlight: false,\n    autoSelect: false,\n    getOptionLabel: (option: any) => {\n      // Value selected with enter, right from the input\n      if (typeof option === 'string' || typeof option === 'number') {\n        return option;\n      }\n\n      // Add \"xxx\" option created dynamically\n      if (option.inputValue) {\n        return option.inputValue;\n      }\n\n      // Regular option\n      return _get(option, optionLabelKey);\n    }\n  };\n\n  const autocompleteCreateOptionProps = {\n    ...autocompleteFreeSoloProps,\n    filterOptions: (options: any[], params: FilterOptionsState<any>) => {\n      const filteredOptions = filterOptions(options, params);\n\n      // Suggest the creation of a new value\n      if (params.inputValue !== '') {\n        filteredOptions.unshift(_set({ inputValue: params.inputValue }, optionLabelKey, `Use \"${params.inputValue}\"`));\n      }\n\n      return filteredOptions;\n    },\n    selectOnFocus: true,\n    clearOnBlur: true,\n    handleHomeEndKeys: true,\n    renderOption: (option: any) => _get(option, optionLabelKey)\n  };\n\n  const autocompleteProps = {\n    ...autocompleteDefaultProps,\n    ...(autocompleteConfig?.freeSolo ? autocompleteFreeSoloProps : {}),\n    ...(allowCreateOption ? autocompleteCreateOptionProps : {}),\n    ...autocompleteConfig\n  };\n\n  return <Autocomplete className={classNames('lc-input-select', className)} {...autocompleteProps} />;\n};\n"],
  "mappings": "+kBAAA,qDACA,iDAQA,sDACA,2BACA,oDACA,uCAEA,mDAEA,2BACA,wDAoBO,KAAM,IAAoC,AAAC,IAW5C,CAX4C,SAChD,WACA,iBAAiB,QACjB,iBACA,OACA,YACA,qBACA,WACA,oBACA,+BATgD,EAU7C,IAV6C,EAU7C,CATH,UACA,iBACA,iBACA,OACA,YACA,qBACA,WACA,oBACA,gCAGA,KAAM,GAAmB,kBAAoB,WAAY,EACnD,EAAgB,iBAAoB,SAEpC,EAAyB,CAAC,EAAa,IAEpC,EAAiB,EAAK,EAAQ,KAAoB,GAAS,EAAS,EAAQ,GAAS,EAAS,EAAQ,GAGzG,EAAoB,CAAC,EAAa,IAC/B,EAAuB,EAAQ,GAGlC,EAAqB,IAAM,CAC/B,KAAM,GAAiB,EAAM,YAAc,EAAK,EAAM,YAAY,OAAQ,GAAQ,EAAM,MAClF,EAAiB,EAAQ,KAAK,GAAU,EAAkB,EAAQ,IAElE,EAAe,EAAgB,GAAK,KAE1C,MAAI,IAAkB,CAAC,GAAkB,EAChC,GAAkB,EAGpB,GAAkB,GAGrB,EAA2B,AAAC,GAAkB,CAClD,GAAI,GAAgB,GAChB,EAAkB,EAEtB,KAAM,GAAiB,EAAQ,KAAK,GAAU,EAAkB,EAAQ,IAGxE,MAAI,GACK,EAAiB,EAAK,EAAgB,GAAkB,EAGjE,CAAI,MAAO,IAAa,SACtB,GAAgB,GAChB,EAAkB,EAAK,GAAI,EAAgB,IAClC,GAAY,EAAS,YAC9B,GAAgB,GAEhB,EAAkB,EAAK,GAAI,EAAgB,EAAS,aAGlD,GACF,GAAkB,EAAK,EAAiB,GAAkB,QAAS,EAAS,YAAc,IAGrF,GAAkB,EAAkB,EAAK,EAAiB,GAAkB,IAG/E,EAA6B,AAAC,GAClC,EAAU,IAAI,GAAY,EAAyB,IAE/C,EAAqB,AAAC,GAC1B,EAAgB,EAA2B,GAAY,EAAyB,GAE5E,EAAgB,CAAC,EAAgB,IACrC,EAAQ,OAAO,GAAU,CACvB,KAAM,GAAc,EAAK,EAAQ,IAAmB,GAC9C,EAAc,GAAU,EAAiB,EAAK,EAAQ,GAAkB,EACxE,EAAa,EAAgB,EAAO,YAE1C,GAAI,GAAa,GACjB,KAAM,GAAa,EAAgB,GAAa,SAAS,GAEzD,MAAI,CAAC,GAAgC,OAAO,IAAgB,UAAY,MAAO,IAAgB,WAC7F,GAAa,EAAgB,GAAa,SAAS,IAG9C,GAAc,IAGnB,EAAkB,IAElB,CAAC,EAAO,GAAY,GAAS,GAInC,GAAU,IAAM,CACd,EAAS,IACR,CAAC,IAEJ,KAAM,GAA8E,CAClF,UACA,QACA,SAAU,CAAC,EAAO,EAAU,EAAQ,IAAY,CAxIpD,cAyIM,KAAM,GAAkB,EAAmB,GAE3C,EAAS,GAET,KAAM,GAAc,YAAM,cAAN,cAAmB,SAAnB,cAA2B,aAA3B,cAAuC,WAAY,MAAM,cAAN,cAAmB,UAC1F,AAAI,MAAM,cAAN,cAAmB,gBACrB,EAAM,YAAY,cAAc,EAAc,KAAK,MAAW,EAAM,GAClE,MAAO,IAAa,YAAY,EAAS,EAAO,EAAiB,EAAQ,IAE/E,YAAa,GACb,UAAW,gBAAC,EAAD,CAAM,UAAU,6BAA6B,KAAK,UAC7D,UAAW,gBAAC,EAAD,CAAM,UAAU,6BAA6B,KAAK,gBAC7D,YAAa,GAAU,CACrB,KAAM,GAAa,SACd,EAAO,YACP,EAAM,YAFQ,CAGjB,SAAU,EAAM,WAGlB,MACE,iBAAC,GAAD,OACE,KAAM,GACF,GACA,GAHN,CAIE,WAAY,EAIZ,YAAa,OAAK,EAAM,aAAX,CAAwB,aAAc,aAIzD,eAAgB,GAAS,gBAAC,GAAD,GAAO,UAAU,yBAA4B,IACtE,eAAgB,AAAC,GAAmC,EAAK,EAAQ,IAAmB,GACpF,kBAAmB,GAAU,EAAO,WACpC,oBACA,gBACA,iBAAkB,GAClB,cAAe,GACf,WAAY,GACZ,aAAc,GACd,WAAY,CAAC,EAAmB,IAC9B,gCACG,EAAW,IAAI,CAAC,EAAgB,IAAU,CACzC,KAAM,GAAiB,EAAQ,KAAK,GAAU,EAAkB,EAAQ,IAClE,EAAQ,EACV,EAAK,EAAgB,GACrB,EAAK,EAAgB,IAAmB,EAC5C,MAAO,iBAAC,GAAD,OAAU,EAAY,CAAE,WAAxB,CAAkC,WAAY,gBAAC,EAAD,CAAM,KAAK,UAAY,MAAO,SAMrF,EAA4B,CAChC,iBAAkB,GAClB,cAAe,GACf,WAAY,GACZ,eAAgB,AAAC,GAEX,MAAO,IAAW,UAAY,MAAO,IAAW,SAC3C,EAIL,EAAO,WACF,EAAO,WAIT,EAAK,EAAQ,IAIlB,EAAgC,OACjC,GADiC,CAEpC,cAAe,CAAC,EAAgB,IAAoC,CAClE,KAAM,GAAkB,EAAc,EAAS,GAG/C,MAAI,GAAO,aAAe,IACxB,EAAgB,QAAQ,EAAK,CAAE,WAAY,EAAO,YAAc,EAAgB,QAAQ,EAAO,gBAG1F,GAET,cAAe,GACf,YAAa,GACb,kBAAmB,GACnB,aAAc,AAAC,GAAgB,EAAK,EAAQ,KAGxC,EAAoB,WACrB,GACC,kBAAoB,UAAW,EAA4B,IAC3D,EAAoB,EAAgC,IACrD,GAGL,MAAO,iBAAC,GAAD,GAAc,UAAW,GAAW,kBAAmB,IAAgB",
  "names": []
}
